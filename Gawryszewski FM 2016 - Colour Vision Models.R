#Colour Vision Models for Trichromatic and Tetrachromatic animals
#Colour Vision Models for Trichromatic and Tetrachromatic animals
#Colour Vision Models for Trichromatic and Tetrachromatic animals

#Updated in 23/Jun/2016

# Felipe M. Gawryszewski, 2016
# Evolution and Sensory Ecology Lab
# Universidade Federal de Goiás
# Goiânia, GO, Brazil
# f.gawry@gmail.com

#data.files
Rb <- data.frame(read.table("/Users/Felipe/Documents/Felipe Virtual/PhD/r/Chittka/Leaf_chittka2005_1nm_linear.txt", header = TRUE))
bee <- data.frame(read.table("/Users/Felipe/Documents/Felipe Virtual/PhD/r/Chittka/Bee_chittka2005_1nm_linear.txt", header = TRUE))
I <- data.frame(read.csv("/Users/Felipe/Documents/Felipe Virtual/PhD/r/Chittka/CIE_Standard_Illuminant_D65.csv", header = TRUE))
I <- I[,c(1,2)]
ciexyz1931<-read.table("~/Desktop/CIE_1931_Colour_matching_functions.txt", header=T)

#write.table(Rb, file="Leaf_chittka2005_1nm_linear.txt", row.names=F, col.names=T)
#write.table(bee, file="Bee_chittka2005_1nm_linear.txt", row.names=F, col.names=T)
#write.table(I, file="CIE_Standard_Illuminant_D65.txt", row.names=F, col.names=T)
#write.table(ciexyz1931, file="CIE_1931_Colour_matching_functions.txt", row.names=F, col.names=T)


#FUNCTIONS:

#1
#smooth spec files
#first column wavelenght; further columns reflectance values
spec.denoise <- function(specfiles, spar1 = 0.7){
  result<-NULL
  name<-names(specfiles)
  for (i in 2:ncol(specfiles)){
    temp<-smooth.spline(x = specfiles[,1], y = specfiles[,i], spar = spar1)$y
    result<-cbind(result,temp)
  }
  result<-data.frame(specfiles[,1], result)
  names(result)<-name
  return(result)
}


#2
#convert energy to flux
#first column wavelenght; second column irradiance in uW/cm2/nm
energytoflux<-function (datum) {
  #datum in uW/cm2/nm
  #converted to µmol/m2/s)
  r<-datum[,2]*datum[,1]*8.357922e-05
  r<-data.frame(datum[,1],r)
  names(r)<-names(datum)
  return(r)
}


#3
#Read spectrometic data generated by OceanOptics spectrometers
read.spec <- function (directory) {
  
  d<-getwd()
  setwd(directory)
  file.names <- dir(directory)
  
  #create store with the correct number of rows
  
  temp <- read.table(file.names[[1]],
                     header = FALSE,
                     skip = 50,
                     comment.char = ">",
                     nrows = 3000)
  temp <- data.frame(temp)
  rows<-nrow(temp)
  temp <- subset(temp, temp[,1] > 299.5)
  temp <- subset(temp, temp[,1] < 700.4)
  store <- matrix(nrow = nrow(temp), ncol = (length(file.names)+1))
  store <- data.frame(store)
  store[,1] <- temp[,1]
  names(store)<-c("wavelenght", paste(file.names))
  
  
  #read the files in order and save in store
  for (i in 1:length(file.names)) {
    print(i)
    temp <- read.table(file.names[[i]],
                       header = FALSE,
                       skip = 50,
                       nrows = rows)
    temp <- data.frame(temp)
    temp <- subset(temp, temp[,c(1)] > 299.5)
    temp <- subset(temp, temp[,c(1)] < 700.4)
    temp <- data.frame(temp)
    temp <- temp[,2]          
    store[,i+1] <- temp
  }
  return(store)
  setwd(d)  
}


logistic<-function(x=seq(300,700,1), x0, L=50, k) {
  y<-L/(1+exp(-k*(x-x0)))
  r<-data.frame(x,y)
  colnames(r)<-c("x","y")
  return(r)
}



#4
#Govardovskii et al. (2000).  Formula to calculate shape of
#absorption spectra based on lambda max
S <- function (lambda.max,
               lambda = seq(300,700,1),
               beta.band = FALSE) {
  A = 69.7
  a = 0.8795 + 0.0459*exp(-1*(((lambda.max-300)^2)/11940))
  B = 28
  b = 0.922
  C = -14.9
  c = 1.104
  D = 0.674
  r <- vector(length = length(lambda))
  for(i in 1:length(lambda)) {
    x <- lambda.max/lambda[[i]]
    r[[i]] <- 1/( exp(A*(a-x)) + exp(B*(b-x)) + exp(C*(c-x)) + D)
  }
  r<-r/max(r)
  
  #beta band
  if (beta.band == TRUE) {
    beta <- vector(length = length(lambda))
    for(i in 1:length(lambda)) {
      lambda.max.beta = 189 + 0.315*lambda.max
      b = -40.5 + 0.195*lambda.max
      A.beta = 0.26
      beta[[i]] <- A.beta*exp(-((lambda[[i]]-lambda.max.beta)/b)^2)
    }
  }
  
  if (beta.band == TRUE) {r <- r + beta}
  
  r <- data.frame(lambda, r)
  colnames(r)<-c("lambda","r")
  return(r)
  
}


#Endler & Mielke 2005
#Radiance spectrum arriving at the viewer
#Q(λ,X) = I(λ) R(λ) T(λ,X) + V(λ)
#I(λ) = Irradiance
#R(λ) = Reflectance
#T(λ,X) = Medium transmission at distance X
#V(λ) = Veiling light (Lythgoe, 1979; Endler, 1990). Veiling light is light from fog or dust particles between the patch and the eye.

#When measuring irradiance (I) it is
#important to use a cosine-corrected
#sensor in order to get realistic and
#accurate measurements of all of the
#light arriving at the surface of
#interest from a 180° solid angle,
#and the sensor must be calibrated
#with a standard light source (see
#Endler, 1990 for details).

#Radiance of the background environment
#where the summation is done over
#the p background colour pattern
#patches within the field of view
#and Rp(λ) is the reflectance
#spectrum of patch p and T(λ, Xp)
#is the transmission to distance Xp.
#It is often easier to measure this
#simply as the sidewelling
#irradiance Is(λ), corrected to the
#solid viewing angle of the eye φ.
#For greatest accuracy E(λ) should
#be measured with a calibrated sensor
#with the appropriate acceptance
#angle φ; this is particularly important
#when the visual background is very
#heterogeneous. The sensor should be
#orientated in the same way as the colour
#pattern to measure the biologically
#and functionally relevant environmental
#irradiance E(λ).

#Somatorio (E)p <- (I, Rp, T, V) OR I angle of view

#WARNING: Tt and V are not implemented

#Q is the radiance spectrum reaching observer's eye
#WARNING: Tt and V are not implemented
Q <- function (R,I,C,Tt = 1,V = 0) {
  #interpolates all spectra to 1nm distance
  nm <- seq(300,700,1)
  I <- approx(x = I[,1], y = I[,2], xout = nm, method="linear")$y
  R <- approx(x = R[,1], y = R[,2], xout = nm, method="linear")$y
  C <- approx(x = C[,1], y = C[,2], xout = nm, method="linear")$y
  
  r <- sum(I*R*C)#*Tt)#+V
  return(r)
}

#Qr = This is known as the von Kries transformation; Cone adaptation
#Qr is the same as P in Chittka's formula
#WARNING: Tt and V are not implemented
Qr <- function(R, I, Rb, C, Tt=1, V=0) {
  Qr <- Q(I,R,C)
  QEr <- Q(I,Rb,C)
  r<-Qr/QEr
  return(r)
}


#L is proportional to perceived brightness (luminance).
#L <- function(ar = 1, Sr.c) {sum(ar*Sr.c)}

#Dmax is the maximum of all possible relative differences between all possible cone outputs.
#Dmax is proportional to perceived chro- maticity or chroma (saturation)
#Dmax <- function (ar = 1, bi = 1, bj = 1, Sr) {
#  S<-Sr
#  r<-max(c(
#    (bi*S[[1]]-bj*S[[2]])/(bi*S[[1]]+bj*S[[2]]),
#    (bi*S[[1]]-bj*S[[3]])/(bi*S[[1]]+bj*S[[3]]),
#    (bi*S[[1]]-bj*S[[4]])/(bi*S[[1]]+bj*S[[4]]),
#    (bi*S[[2]]-bj*S[[3]])/(bi*S[[2]]+bj*S[[3]]),
#    (bi*S[[2]]-bj*S[[4]])/(bi*S[[2]]+bj*S[[4]]),
#    (bi*S[[3]]-bj*S[[4]])/(bi*S[[3]]+bj*S[[4]])
#  ))
#  return(r)
#}



#5
#Endler's Visual Model
#Endler's Visual Model
#Endler's Visual Model
#Endler's Visual Model

#log: Use the log-linear version of the von Kries transformation
#rmNEG: transfrom to 0 negative values generated by log tranformation when 'S' < 1
#I: Irradiance spectrum
#R: Reflectance of observed object
#Rb: Background reflectance
#C1: Photoreceptor 1
#C2: Photoreceptor 2
#C3: Photoreceptor 3
#C4: Photoreceptor 4, for tetrachromatic animals. Used when photo = "tetra".
#photo: "tri" or "tetra". Model for trichromatic or tetrachromatic animals
#Tt: not implemented
#V: not implemented


Endler <- function (log = c("nolog", "log", "log1"),
                    photo=c("tri","tetra"),
                    R,
                    I,
                    Rb,
                    C1,
                    C2,
                    C3,
                    C4=0,
                    Tt=1,
                    V=0)
  {
  
  S1 <- Qr(I=I, R=R, Rb=Rb, C=C1, Tt=1, V=0)
  if (log=="nolog") {S1 <- S1}
  if (log=="log1") {S1 <- log(1+S1)}
  if (log=="log") {S1 <- log(S1)}
  
  S2 <- Qr(I=I, R=R, Rb=Rb, C=C2, Tt=1, V=0)
  if (log=="nolog") {S2 <- S2}
  if (log=="log1") {S2 <- log(1+S2)}
  if (log=="log") {S2 <- log(S2)}
  
  S3 <- Qr(I=I, R=R, Rb=Rb, C=C3, Tt=1, V=0)
  if (log=="nolog") {S3 <- S3}
  if (log=="log1") {S3 <- log(1+S3)}
  if (log=="log") {S3 <- log(S3)}
  
  if(photo=="tetra") {S4 <- Qr(I=I, R=R, Rb=Rb, C=C4, Tt=1, V=0)
  if (log=="nolog") {S4 <- S4}
  if (log=="log1") {S4 <- log(1+S4)}
  if (log=="log") {S4 <- log(S4)}
  }
  
  #if (rmNEG==TRUE) {
  #  
  #  S1[S1<0] <- 0
  #  S2[S2<0] <- 0
  #  S3[S3<0] <- 0
  #  if(photo=="tetra") {S4[S4<0] <- 0}
  #}
    
  if(photo=="tri") {S <-c(S1,S2,S3)}
  if(photo=="tetra") {S <-c(S1,S2,S3,S4)}
  
  u <- S[[1]]/sum(S)
  s <- S[[2]]/sum(S)
  m <- S[[3]]/sum(S)
  if(photo=="tetra") {l <- S[[4]]/sum(S)}
  
  if(photo=="tri") {
    x <- (2/3)*((sqrt(3)/2)*(m-u))
    y <- (2/3)*(s-0.5*(u+m))
  }
  
  if(photo=="tetra") {
    x <- ((1-2*s-m-u)/2)*sqrt(3/2)
    y <- (-1+3*m+u)/(2*sqrt(2))
    z <- u - 1/4
  }
  
  if(photo=="tetra") {
    
    deltaSo<-sqrt(x^2+y^2+z^2)
    
    r<-c(S1, S2, S3, S4, u, s, m, l, x, y, z, deltaSo)
    r<-as.vector(r)
    names(r)<-c("S1", "S2", "S3", "S4", "u", "s", "m", "l", "x", "y", "z", "deltaSo")  
    return(r) 
  }
  
  if(photo=="tri") {
    
    deltaSo<-sqrt(x^2+y^2)
    
    r<-c(S1, S2, S3, u, s, m, x, y, deltaSo)
    r<-as.vector(r)
    names(r)<-c("S1", "S2", "S3", "u", "s", "m", "x", "y", "deltaSo") 
    return(r)}
  
}




#6
#Vorobyev Osorio
#Vorobyev Osorio
#Vorobyev Osorio
#Vorobyev Osorio
#Noise corrected measure of deltaE

#log: use the log-linear version of the von Kries transformation (Vorobyev et al., 1998, 2001)
#rmNEG: transfrom to 0 negative values generated by log tranformation when 'S' < 1
#I: Irradiance spectrum
#R1: Reflectance of object 1
#R2: Reflectance of object 2
#Rb: Background reflectance
#C1: Photoreceptor 1
#C2: Photoreceptor 2
#C3: Photoreceptor 3
#C4: Photoreceptor 4, for tetrachromatic animals. Used when photo = "tetra".
#photo: "tri" or "tetra". Model for trichromatic or tetrachromatic animals
#Tt: not implemented
#V: not implemented
#g: relative number of each photoreceptor in the retina. Usually increases with lambda-max. Used to calculate 'e' when noise = FALSE.
#w: Weber fraction. Value of 0.05 is typical for vertebrates. Used to calculate 'e' when noise = FALSE
#noise: receptor noise of each photoreceptor given by 'e'.
#e: receptor noise of each photoreceptor. Honeybee: e = c(0.13, 0.06, 0.12) (Vorobyev & Brandt 1997). Used when noise = TRUE

#"Receptor signals are the functions of the receptor quantum catches,
#and two simple models relating the receptor signals to quantum catches
#can be considered: (i) linear relation (Vorobyev & Osorio, 1998);
#(ii) log–lin- ear relation (Vorobyev, Osorio, Bennett, Marshall, & Cuthill, 1998).
#Because results of our model calcula- tions do not depend on the units
#in which receptor signals are measured, receptor signals can be
#re-scaled so that they are related to quantum catches
#by fi = qi or fi = ln(q ) for the linear or log – linear models,
#respectively. Note that for the stimuli which are close to a reference
#both models give equal predictions (..)" from Vorobyev et al. (2001)

noise_e <- function (w=0.05,g) {
  r<-w/sqrt(g)
  return(r)
}

VorOso <- function(log = c("nolog", "log", "log1"),
                   photo=c("tri","tetra"), R1, R2, Rb, I, C1, C2, C3, C4=0, Tt=1, V=0,
                   noise=FALSE, e=NA, g = c(1,1,2), w=0.05) {
 
  if (noise==FALSE) {
    #noise of each photoreceptor
    noiseS1<-noise_e(w,g[[1]])
    noiseS2<-noise_e(w,g[[2]])
    noiseS3<-noise_e(w,g[[3]])
    if(photo=="tetra") {noiseS4<-noise_e(w,g[[4]])}
  }
  if (noise==TRUE) {  
    noiseS1<-e[[1]]
    noiseS2<-e[[2]]
    noiseS3<-e[[3]]
    if(photo=="tetra") {noiseS4<-e[[4]]}    
  }
  
  #Sr values for colour patch 1 (R1)
  S1.1 <- Qr(I=I, R=R1, Rb=Rb, C=C1, Tt=1, V=0)
  if (log=="nolog") {S1.1 <- S1.1}
  if (log=="log1") {S1.1 <- log(1+S1.1)}
  if (log=="log") {S1.1 <- log(S1.1)}
  
  S2.1 <- Qr(I=I, R=R1, Rb=Rb, C=C2, Tt=1, V=0)
  if (log=="nolog") {S2.1 <- S2.1}
  if (log=="log1") {S2.1 <- log(1+S2.1)}
  if (log=="log") {S2.1 <- log(S2.1)}
  
  S3.1 <- Qr(I=I, R=R1, Rb=Rb, C=C3, Tt=1, V=0)
  if (log=="nolog") {S3.1 <- S3.1}
  if (log=="log1") {S3.1 <- log(1+S3.1)}
  if (log=="log") {S3.1 <- log(S3.1)}
  
  if(photo=="tetra") {S4.1 <- Qr(I=I, R=R1, Rb=Rb, C=C4, Tt=1, V=0)
  if (log=="nolog") {S4.1 <- S4.1}
  if (log=="log1") {S4.1 <- log(1+S4.1)}
  if (log=="log") {S4.1 <- log(S4.1)}
  }
  
  #Sr values for colour patch 2 (R2)
  S1.2 <- Qr(I=I, R=R2, Rb=Rb, C=C1, Tt=1, V=0)
  if (log=="nolog") {S1.2 <- S1.2}
  if (log=="log1") {S1.2 <- log(1+S1.2)}
  if (log=="log") {S1.2 <- log(S1.2)}
  
  S2.2 <- Qr(I=I, R=R2, Rb=Rb, C=C2, Tt=1, V=0)
  if (log=="nolog") {S2.2 <- S2.2}
  if (log=="log1") {S2.2 <- log(1+S2.2)}
  if (log=="log") {S2.2 <- log(S2.2)}
  
  S3.2 <- Qr(I=I, R=R2, Rb=Rb, C=C3, Tt=1, V=0)
  if (log=="nolog") {S3.2 <- S3.2}
  if (log=="log1") {S3.2 <- log(1+S3.2)}
  if (log=="log") {S3.2 <- log(S3.2)}
  
  if(photo=="tetra") {S4.2 <- Qr(I=I, R=R2, Rb=Rb, C=C4, Tt=1, V=0)
    if (log=="nolog") {S4.2 <- S4.2}
    if (log=="log1") {S4.2 <- log(1+S4.2)}
    if (log=="log") {S4.2 <- log(S4.2)}
  }
  
  #if (rmNEG==TRUE) {
  #  
  #  S1.1[S1.1<0] <- 0
  #  S2.1[S2.1<0] <- 0
  #  S3.1[S3.1<0] <- 0
  #  if(photo=="tetra") {S4.1[S4.1<0] <- 0}
    
  #  S1.2[S1.2<0] <- 0
  #  S2.2[S2.2<0] <- 0
  #  S3.2[S3.2<0] <- 0
  #  if(photo=="tetra") {S4.2[S4.2<0] <- 0}
    
  #}

  if(photo=="tetra"){
    
    #Delta E = 1 is the just noticible diference (JND)
    delta_e <- sqrt (
      ((((noiseS1*noiseS2)^2)*((S4.1-S4.2)-(S3.1-S3.2))^2)+
         (((noiseS1*noiseS3)^2)*((S4.1-S4.2)-(S2.1-S2.2))^2)+
         (((noiseS2*noiseS3)^2)*((S4.1-S4.2)-(S1.1-S1.2))^2)+
         (((noiseS1*noiseS4)^2)*((S3.1-S3.2)-(S2.1-S2.2))^2)+
         (((noiseS2*noiseS4)^2)*((S3.1-S3.2)-(S1.1-S1.2))^2)+
         (((noiseS3*noiseS4)^2)*((S2.1-S2.2)-(S1.1-S1.2))^2))
      /
        (((noiseS2*noiseS3*noiseS4)^2)+
           ((noiseS1*noiseS3*noiseS4)^2)+
           ((noiseS1*noiseS2*noiseS4)^2)+
           ((noiseS1*noiseS2*noiseS3)^2))
    )
    
    r<-c(delta_e,noiseS1,noiseS2,noiseS3,noiseS4,S1.1,S2.1,S3.1,S4.1,S1.2,S2.2,S3.2,S4.2)
    r<-as.vector(r)
    names(r)<-c("delta_e","noiseS1","noiseS2","noiseS3","noiseS4","S1.1","S1.2","S1.3","S1.4","S2.1","S2.2","S2.3","S2.4")
  }
  
  if(photo=="tri"){
    
    delta_e <- sqrt ( (((noiseS1^2)*(((S3.1-S3.2)-(S2.1-S2.2))^2)+
                          (noiseS2^2)*(((S3.1-S3.2)-(S1.1-S1.2))^2)+
                          (noiseS3^2)*(((S1.1-S1.2)-(S2.1-S2.2))^2))/
                         (((noiseS1*noiseS2)^2)+((noiseS1*noiseS3)^2)+((noiseS2*noiseS3)^2))
    )
    )
    
    r<-c(delta_e,noiseS1,noiseS2,noiseS3,S1.1,S2.1,S3.1,S1.2,S2.2,S3.2)
    r<-as.vector(r)
    names(r)<-c("delta_e","noiseS1","noiseS2","noiseS3","S1.1","S2.1","S3.1","S1.2","S2.2","S3.2")
  }
  
  return(r)
  
}





#Kelber, Vorobyev & Osorio (2003)
#Kelber, Vorobyev & Osorio (2003)
#Kelber, Vorobyev & Osorio (2003)
#Kelber <- function(rmNEG=FALSE, R1, Rb, I, C1, C2, C3, Tt=1, V=0,
#                   g = c(1,1,2), w=0.05, noise=FALSE, e=NA) {
#  
#  log <- TRUE
#  photo <- "tri"
#  
#  if (noise==FALSE) {
#    #noise of each photoreceptor
#    noiseS1<-noise_e(w,g[[1]])
#    noiseS2<-noise_e(w,g[[2]])
#    noiseS3<-noise_e(w,g[[3]])
#  }
#  if (noise==TRUE) {  
#    noiseS1<-e[[1]]
#    noiseS2<-e[[2]]
#    noiseS3<-e[[3]]
#  }
#  
#  #Sr values for colour patch 1 (R1)
#  S1.1 <- Qr(I=I, R=R1, Rb=Rb, C=C1, Tt=1, V=0)
#  if (log==TRUE) {S1.1 <- log(1+S1.1)}
#  
#  S2.1 <- Qr(I=I, R=R1, Rb=Rb, C=C2, Tt=1, V=0)
#  if (log==TRUE) {S2.1 <- log(1+S2.1)}
#  
#  S3.1 <- Qr(I=I, R=R1, Rb=Rb, C=C3, Tt=1, V=0)
#  if (log==TRUE) {S3.1 <- log(1+S3.1)}
#  
#  #Sr values for colour patch 2 (R2)
#  #S1.2 <- Qr(I=I, R=R2, Rb=Rb, C=C1, Tt=1, V=0)
#  #if (log==TRUE) {S1.2 <- log(S1.2)}
#  #
#  #S2.2 <- Qr(I=I, R=R2, Rb=Rb, C=C2, Tt=1, V=0)
#  #if (log==TRUE) {S2.2 <- log(S2.2)}
#  #
#  #S3.2 <- Qr(I=I, R=R2, Rb=Rb, C=C3, Tt=1, V=0)
#  #if (log==TRUE) {S3.2 <- log(S3.2)}
#  #
#  #if(photo=="tetra") {S4.2 <- Qr(I=I, R=R2, Rb=Rb, C=C4, Tt=1, V=0)
#  #if (log==TRUE) {S4.2 <- log(S4.2)}
#  #}
#  
#  if (rmNEG==TRUE) {
#    
#    S1.1[S1.1<0] <- 0
#    S2.1[S2.1<0] <- 0
#    S3.1[S3.1<0] <- 0
#    if(photo=="tetra") {S4.1[S4.1<0] <- 0}
#    
#    #S1.2[S1.2<0] <- 0
#    #S2.2[S2.2<0] <- 0
#    #S3.2[S3.2<0] <- 0
#    #if(photo=="tetra") {S4.2[S4.2<0] <- 0}
#    
#  }
#  
#  if(photo=="tri"){
#    
#    A = sqrt(1/(noiseS2^2+noiseS3^2))
#    B = sqrt( (noiseS2^2+noiseS3^2) /( (noiseS1*noiseS2)^2+(noiseS1*noiseS3)^2+(noiseS2*noiseS3)^2 ))
#    
#    a = (noiseS2^2) / (noiseS2^2 + noiseS3^2)
#    b = (noiseS3^2) / (noiseS2^2 + noiseS3^2)
#    
#    X1 = A * (S3.1 - S2.1)
#    X2 = B * (S1.1 - (a*S2.1 + b*S2.1))
#    
#    deltaS <- sqrt(X1^2+X2^2)
#    
#    r<-c(deltaS,noiseS1,noiseS2,noiseS3,S1.1,S2.1,S3.1)
#    names(r)<-c("deltaS","noiseS1","noiseS2","noiseS3","S1.1","S2.1","S3.1")
#  }
#  
#  return(r)
#  
#}





#7
#Chittka 1992 - Colour Hexagon
#Chittka 1992 - Colour Hexagon
#Chittka 1992 - Colour Hexagon

#I: Irradiance spectrum
#R: Reflectance of observed object
#Rb: Background reflectance
#C1: Photoreceptor 1
#C2: Photoreceptor 2
#C3: Photoreceptor 3
#C4: Photoreceptor 4, for tetrachromatic animals. Used when photo = "tetra".
#photo: "tri" or "tetra". Model for trichromatic or tetrachromatic animals
#Tt: not implemented
#V: not implemented

Cttk <- function (photo=c("tri", "tetra"),
                  R,
                  I,
                  Rb,
                  C1,
                  C2,
                  C3,
                  C4=0,
                  Tt=1,
                  V=0)

{

  Puv <- Qr(I=I, R=R, Rb=Rb, C=C1, Tt=Tt, V=V)
  Pb <- Qr(I=I, R=R, Rb=Rb, C=C2, Tt=Tt, V=V)
  Pg <- Qr(I=I, R=R, Rb=Rb, C=C3, Tt=Tt, V=V)
  if(photo=="tetra") {Pr <- Qr(I=I, R=R, Rb=Rb, C=C4, Tt=Tt, V=V)}

  Euv <- Puv/(1+Puv)
  Eb <- Pb/(1+Pb)
  Eg <- Pg/(1+Pg)
  if(photo=="tetra") {Er <- Pr/(1+Pr)}


  if(photo=="tri") { 

  E <- c(Euv, Eb, Eg)
  names(E) <- c("Euv", "Eb", "Eg")
    
  x <- sin(3/pi)*(Eg-Euv)
  y <- Eb-0.5*(Eg+Euv)
  
  deltaSo<-sqrt(x^2+y^2) 
  
  E <- c(Euv, Eb, Eg, x, y, Puv, Pb, Pg, deltaSo)
  E <- as.vector(E)
  names(E) <- c("E1", "E2", "E3", "x", "y", "P1", "P2", "P3", "deltaSo")
  }
  
  if(photo=="tetra") {  
  
  E <- c(Euv, Eb, Eg, Er)
  E <- as.vector(E)
  names(E) <- c("Euv", "Eb", "Eg", "Er")
    
  x <- ((2*sqrt(2))/3)* 0.866025404 * (E[["Eg"]]-E[["Er"]]) 
  y <- E[["Euv"]] - (1/3)*(E[["Eb"]]+E[["Eg"]]+E[["Er"]])  
  z <- ((2*sqrt(2))/3) * ( ( 0.5*(E[["Eg"]]+E[["Er"]]) ) - E[["Eb"]] )
  
  deltaSo<-sqrt(x^2+y^2+z^2)
  
  E <- c(Euv, Eb, Eg, Er, x, y, z, Puv, Pb, Pg, Pr, deltaSo)
  E <- as.vector(E)
  names(E) <- c("E1", "E2", "E3", "E4", "x", "y", "z", "P1", "P2", "P3", "P4", "deltaSo")
  }
  
  return(E)
  
}


#8
#Plot Chittka's hexagon
#Plot Chittka's hexagon
#Plot Chittka's hexagon
plot.hexagon <- function (main = NULL) {
  
  plot(main = main, x=0,y=0, pch=16, bty="n",yaxt="n",xaxt="n", col="white", ylim=c(-1.2,1.2), xlim=c(-1.2,1.2), asp=1)
  polygon(x=c(0,0.86660254,0.86660254,0,-0.86660254,-0.86660254,0),
          y=c(1,0.5,-0.5,-1,-0.5,0.5,1))
  legend(x=-0.025,y=1.25,legend = expression(E[blue]), bty="n", xjust=0.5)
  legend(x=-0.93,y=-0.47,legend = expression(E[UV]), bty="n", xjust=0.5)
  legend(x=0.87,y=-0.47,legend = expression(E[green]), bty="n", xjust=0.5)
  
}

#plot.hexagon3D <- function (theta=60,
#                            phi=60,
#                            r = sqrt(3),
#                            main = NULL,
#                            xlim = c(-2,2),
#                            ylim = c(-2,2),
#                            zlim = c(-2,2)) {
#  require(plot3D)
#  smu <- function (u,s,m,l) {
#    
#    x <- ((2*sqrt(2))/3)*0.866025404*(m-l)  
#    y <- u - (1/3)*(s+m+l)  
#    z <- (2*sqrt(2))/3 * ( ( 0.5*(m+l) ) - s )
#    r<-c(x,y,z)
#    names(r)<-c("x","y","z")
#    return(r)
#  }
#  x<-c(
#    smu(1,1,1,0)[["x"]],#1
#    smu(1,1,0,0)[["x"]],#2
#    smu(1,0,0,0)[["x"]],#3
#    smu(0,1,1,1)[["x"]],#4
#    smu(0,0,1,1)[["x"]],#5
#    smu(0,0,0,1)[["x"]],#6
#    smu(0,0,1,0)[["x"]],#7
#    smu(0,1,0,0)[["x"]],#8
#    smu(0,1,1,0)[["x"]],#9
#    smu(1,0,0,1)[["x"]],#10
#    smu(1,1,0,1)[["x"]],#11
#    smu(1,0,1,1)[["x"]]#12
#  )
#  y<-c(
#    smu(1,1,1,0)[["y"]],#1
#    smu(1,1,0,0)[["y"]],#2
#    smu(1,0,0,0)[["y"]],#3
#    smu(0,1,1,1)[["y"]],#4
#    smu(0,0,1,1)[["y"]],#5
#    smu(0,0,0,1)[["y"]],#6
#    smu(0,0,1,0)[["y"]],#7
#    smu(0,1,0,0)[["y"]],#8
#    smu(0,1,1,0)[["y"]],#9
#    smu(1,0,0,1)[["y"]],#10
#    smu(1,1,0,1)[["y"]],#11
#    smu(1,0,1,1)[["y"]]#12
#  )
#  z<-c(
#    smu(1,1,1,0)[["z"]],#1
#    smu(1,1,0,0)[["z"]],#2
#    smu(1,0,0,0)[["z"]],#3
#    smu(0,1,1,1)[["z"]],#4
#    smu(0,0,1,1)[["z"]],#5
#    smu(0,0,0,1)[["z"]],#6
#    smu(0,0,1,0)[["z"]],#7
#    smu(0,1,0,0)[["z"]],#8
#    smu(0,1,1,0)[["z"]],#9
#    smu(1,0,0,1)[["z"]],#10
#    smu(1,1,0,1)[["z"]],#11
#    smu(1,0,1,1)[["z"]]#12
#  )
  
#    text3D(x=x,y=y,z=z,
#            c("1","2","3","4","5","6","7","8","9","10","11","12"),
#            theta=theta,
#            phi=phi,
#            r = r,
#            main = main,
#            colvar=NULL,
#            xlim = xlim,
#            ylim = ylim,
#            zlim = zlim,
#            pch=21
#            #surf = list(x = as.matrix(x), y = as.matrix(y), z=as.matrix(z), border = "black", facets = NA)
#            #,bty="n",yaxt="n",xaxt="n",add=FALSE,col="black"
#  )
#}


#9
#Plot Endler's Triangle
#Plot Endler's Triangle
#Plot Endler's Triangle
#Plot Endler's Triangle
plot.triangle <- function (main = NULL,
                           ylim=c(-0.8,0.8),
                           xlim=c(-0.8,0.8)) {
  
  plot(x=0,y=0, pch=16, bty="n",yaxt="n",xaxt="n", col="white",
       ylim=ylim, xlim=xlim, asp=1, main=main)
  polygon(x=c((2/3)*((sqrt(3)/2)*(0-1)),
              (2/3)*((sqrt(3)/2)*(0-0)),
              (2/3)*((sqrt(3)/2)*(1-0))
  ),
  y=c((2/3)*(0-0.5*(1+0)),
      (2/3)*(1-0.5*(0+0)),
      (2/3)*(0-0.5*(0+1))
  )
  )
  legend(x=(2/3)*((sqrt(3)/2)*(0-1)),
         y=(2/3)*(0-0.5*(1+0)),
         legend = expression(E[UV]), bty="n", xjust=0.5, yjust=1)
  legend(x=(2/3)*((sqrt(3)/2)*(0-0)),
         y=(2/3)*(1-0.5*(0+0)),
         legend = expression(E[Blue]), bty="n", xjust=0.5, yjust=0)
  legend(x=((2/3)*((sqrt(3)/2)*(1-0))),
         y=(2/3)*(0-0.5*(0+1)),legend = expression(E[green]),
         bty="n", xjust=0.5, yjust=1)
  
}


#10
#Plot Endler's Tetrahedron
#Plot Endler's Tetrahedron
#Plot Endler's Tetrahedron
#Plot Endler's Tetrahedron
plot.tetra <- function (theta=120,
                        phi=120,
                        r = sqrt(3),
                        main = NULL,
                        xlim = c(-0.5,0.5),
                        ylim = c(-0.5,0.5),
                        zlim = c(-0.5,0.5)) {
  
  library(plot3D)
  smu <- function (s,m,u,l) {
    
    x <- ((1-2*s-m-u)/2)*sqrt(3/2)
    y <- (-1+3*m+u)/(2*sqrt(2))
    z <- u - 1/4
    r<-c(x,y,z)
    names(r)<-c("x","y","z")
    return(r)
  }
  lines3D(x=c(smu(1,0,0)[["x"]],
              smu(0,0,0)[["x"]],
              smu(0,0,1)[["x"]],
              smu(1,0,0)[["x"]]),
          y=c(smu(1,0,0)[["y"]],
              smu(0,0,0)[["y"]],
              smu(0,0,1)[["y"]],
              smu(1,0,0)[["y"]]),
          z=c(smu(1,0,0)[["z"]],
              smu(0,0,0)[["z"]],
              smu(0,0,1)[["z"]],
              smu(1,0,0)[["z"]]),
          theta=theta,
          phi=phi,
          r = r,
          main = main,
          colvar=NULL,
          xlim = xlim,
          ylim = ylim,
          zlim = zlim,
          bty="n",yaxt="n",xaxt="n",add=FALSE,col="black"
  )
  
  lines3D(x=c(smu(1,0,0)[["x"]],
              smu(0,1,0)[["x"]],
              smu(0,0,1)[["x"]]
  ),
  y=c(smu(1,0,0)[["y"]],
      smu(0,1,0)[["y"]],
      smu(0,0,1)[["y"]]
  ),
  z=c(smu(1,0,0)[["z"]],
      smu(0,1,0)[["z"]],
      smu(0,0,1)[["z"]]
  ),
  add=TRUE,
  colvar=NULL,bty="n",yaxt="n",xaxt="n",col="black")
  
  lines3D(x=c(smu(0,0,0)[["x"]],
              smu(0,1,0)[["x"]]),
          y=c(smu(1,0,0)[["y"]],
              smu(0,1,0)[["y"]]),
          z=c(smu(1,0,0)[["z"]],
              smu(0,1,0)[["z"]]),
          add=TRUE,colvar=NULL,bty="n",yaxt="n",xaxt="n",col="black")
  
  text3D(labels = c("UV","B","G","R"),
         x=c(smu(1,0,0)[["x"]],smu(0,1,0)[["x"]],smu(0,0,1)[["x"]],smu(0,0,0)[["x"]]),
         y=c(smu(1,0,0)[["y"]],smu(0,1,0)[["y"]],smu(0,0,1)[["y"]],smu(0,0,0)[["y"]]),
         z=c(smu(1,0,0)[["z"]],smu(0,1,0)[["z"]],smu(0,0,1)[["z"]],smu(0,0,0)[["z"]]),
         colvar=NULL,bty="n",yaxt="n",xaxt="n",add=T,col="black")
}


#CIE Human colour perception
#x: CIE 1931 Colour matching function x
#y: CIE 1931 Colour matching function y
#z: CIE 1931 Colour matching function z
#x,y,z functions available in http://www.cie.co.at/publ/abst/datatables15_2004/CIE_sel_colorimetric_tables.xls
#r: reflectance spectrum
#plot: plot human colour
#rgb: RGB colour space to be used for conversion from XYZ to RGB
CIEXYZ<-function (fx,
                   fy,
                   fz,
                   r,
                   c.rgb="sRGB",
                   plot=TRUE
                   ) {
  nm<-seq(380,780,1)
  x1<-approx(x = fx[,1], y = fx[,2], xout = nm, method="linear")
  y1<-approx(x = fy[,1], y = fy[,2], xout = nm, method="linear")
  z1<-approx(x = fz[,1], y = fz[,2], xout = nm, method="linear")
  r1<-approx(x = r[,1], y = r[,2], xout = nm, method="linear")
  X<-sum(x1$y*r1$y, na.rm = T)  
  Y<-sum(y1$y*r1$y, na.rm = T)  
  Z<-sum(z1$y*r1$y, na.rm = T) 
  
  #chromaticity coordinates:
  x2<-X/(X+Y+Z)
  y2<-Y/(X+Y+Z)
  z2<-Z/(X+Y+Z)

  require(grDevices)
  rgb<-convertColor(color=c(x2,y2,z2), from="XYZ", to=c.rgb, clip=TRUE)
  result<-c(x2,y2,z2,X,Y,Z,rgb[[1]],rgb[[2]],rgb[[3]])
  result<-as.vector(result)
  names(result)<-c("x","y","z","sumX","sumY","sumZ","R","G","B")
  if(plot==TRUE){
    plot(r, type="l", lwd=2, ylab="Reflectance (%)", xlab="Wavelength (nm)",ylim=c(0,100))
    points(x=min(r[,1]),y=100,
           bg=rgb(red=result[["R"]],green=result[["G"]],blue=result[["B"]], alpha=1), col="black", cex=60, pch=22)
      }
  return(result)
} 




